# -*- coding: utf-8 -*-
"""auth module

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lQI8PdzdblJB6V6PreqSn06wlVjhtYPO
"""

# -*- coding: utf-8 -*-
"""new 09/09/25 auth module

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oy1mAPDlalt_dSnwOhhNOdWmcck2yOw2
"""

from __future__ import annotations
from fastapi import FastAPI, Request, Response, HTTPException, status, Cookie, Depends
from fastapi.responses import FileResponse, HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field
from dataclasses import dataclass, asdict
from typing import Optional, Iterable, Annotated, Tuple, List
import os
import hmac
import uuid
import json
import secrets
import hashlib
import sqlite3
from datetime import datetime, timedelta, timezone

"""# SQL Database and Table Creation"""

# SQL database setup # ADD PARTICLES TABLE
DB_FILE = "pim.db"
COOKIE_NAME = "session"

# -------------------- DB --------------------
con = sqlite3.connect(DB_FILE, check_same_thread=False) #added so that
# only the thread that issues this command may use it
con.execute("PRAGMA foreign_keys = ON") # ensures that you cannot insert/update/
#delete file if they are being references elsewhere

# creating the necessary tables: Users, Sessions
# FailedLogins table will be used to implement lockout as necessary
con.executescript(
"""
CREATE TABLE IF NOT EXISTS Users(
  user_id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE,
  password TEXT,           -- legacy/unused
  token TEXT,              -- compatibility with particles.py
  password_salt TEXT,
  password_hash TEXT
);

CREATE TABLE IF NOT EXISTS Sessions(
  session_token TEXT PRIMARY KEY,
  signature TEXT NOT NULL,
  user_id INTEGER NOT NULL,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  user_agent TEXT,
  ip TEXT,
  FOREIGN KEY(user_id) REFERENCES Users(user_id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS FailedLogins(
  username TEXT PRIMARY KEY,
  fail_count INTEGER NOT NULL DEFAULT 0,
  last_failed_at TEXT
);
"""
)
con.commit()

"""# Data Structures"""

# Necessary data structures to store Users and Particles
@dataclass
class User:
    user_id: Optional[int]
    username: str
    password: str
    token: Optional[str]

@dataclass
class Particle:
    particle_id: Optional[int]
    date_created: datetime
    date_updated: datetime
    title: str
    body: str
    tags: List[str]
    particle_references: List[str]

"""# Tests for Data Structures"""

# creating a test user
test_User = User(None, "AbsoluteZero", "password", None)
print(test_User, f"\n")

#creating a test particle
test_Particle = Particle(particle_id=None, date_created=datetime.now(), date_updated=datetime.now(), title="test", body="test", tags=["test"], particle_references=["test"])
print(test_Particle)

"""# Password Encryption and Verification Functions"""

# saving constants that are to be used for password encryption
PBKDF_ALGO = "sha256"
PBKDF_ITER = 200_000
SALT_BYTES = 32
HASH_BYTES = 32

# helper functions to convert to and from hexadecimal format
def hex(b: bytes) -> str:
  """This function utilizes the inbuilt .hex() function to convert a byte
  string into a hexadecimal string for encryption.

  :param b: is a collection of bytes,
  :type b: bytes
  ...
  :raises [ErrorType]: [ErrorDescription]
  ...
  :return: a string in the hexadecimal format
  :rtype: str
  """
  return b.hex()

def unhex(s: str) -> bytes:
  """This function converts a hexadecimal string into a byte string using the fromhex() function.

  :param s: it is a hexadecimal string
  :type s: str
  ...
  :raises [ErrorType]: [ErrorDescription]
  ...
  :return: returns a byte string
  :rtype: bytes
  """
  return bytes.fromhex(s or "")

# primary hashing function to be utilized for ensuring password security
def hash_password(plain: str) -> tuple[str, str]:
  """This function first generates a salt on the basis of a preset number of
  bytes then utilizes the hashlib.pbdkdf2_hmac() method to encrypt the password
  repeatedly to protect it against attacks and it returns a tuple including
  both the salt used and the hashed password in a hexadecimal format

  :param plain: this inputs the password to be hashed
  :type plain: str
  ...
  :raises [ErrorType]: [ErrorDescription]
  ...
  :return: tuple containing the salt and hashed password
  :rtype: tuple[str, str]
  """
  salt = os.urandom(SALT_BYTES)
  digest = hashlib.pbkdf2_hmac(PBKDF_ALGO, plain.encode(), salt, PBKDF_ITER, dklen=HASH_BYTES)
  return hex(salt), hex(digest)

def verify_password(plain: str, salt_hex: str, hash_hex: str) -> bool:
  """This functions checks the stored, previously encrypted password against
  the newly entered password by putting it through a similar hashing and then
  comparing it with the stored hash.

  :param plain: takes the entered password
  :type plain: str
  :param salt_hex: requires the specific salt used to encryp the original
  password as input
  :type salt_hex: str
  :param hash_hex: requires the hexidecimal version of the original
  password as input
  :type hash_hex: str
  ...
  :raises [ErrorType]: [ErrorDescription]
  ...
  :return: tells you whether or not the entered password matches the set
  password
  :rtype: bool
  """
  if not salt_hex or not hash_hex:
    return False
  # the earlier hash_password() function can also be used here we would just
  # need to change the return type and specify we want to check it against the
  # second value in the tuple i.e., [1]
  test = hashlib.pbkdf2_hmac(PBKDF_ALGO, plain.encode(), unhex(salt_hex), PBKDF_ITER, dklen=len(unhex(hash_hex)))
  return hmac.compare_digest(test, unhex(hash_hex))

"""# Tests for Encryption and Verification Functions"""

# testing the hex function
test_hex = hex(b"hello")
print(test_hex)

#testing the unhex function
print(unhex(test_hex))

#testing the hashing function for passwords
test_password = hash_password("password")
print(test_password) #returns both the salt used as well as the hashed
# password

#testing the password verification function
print(verify_password("password", test_password[0], test_password[1]))

"""# Login Lockout Functions"""

# functions to implement login lockout as necessary on the basis of the
# number of failed attempts
def login_backoff_seconds(username: str) -> int:
  # confirm summary with anshikha
  """This function calculates how many seconds it will lockout the user for
  after confirming whether they need to be locked out or not

  :param username: it is the username of the user whose login lockeout is
  being calculated
  :type str: [ParamType](, optional)
  ...
  :return: the number of seconds the user will be locked out for
  :rtype: int
  """
  row = con.execute("SELECT fail_count, last_failed_at FROM FailedLogins WHERE username = ?", (username,)).fetchone()
  if not row:
    return 0
  fails, last = row
  if not last or fails <= 3:
    return 0
  last_dt = datetime.fromisoformat(last)
  minutes = min(2 ** (fails - 3), 30)
  unlock_time = last_dt + timedelta(minutes=minutes)
  return max(0, int((unlock_time - datetime.now(timezone.utc)).total_seconds()))

def record_login_failure(username: str) -> None:
  """Checks if a user already has failed attempts: if they do, it increments
  the pre-exisiting value by 1; and if they do not, it adds the user
  to the table and increments their login failure value by 1. It maintains
  the table for the other login failure functions to work optimally.

  :param username: name of the user trying to login
  :type username: str
  ...
  :raises [ErrorType]: [ErrorDescription]
  ...
  :return: just adds or updates the row and increments the value of failed logins and
  does not return anything
  :rtype: None
  """
  row = con.execute("SELECT fail_count FROM FailedLogins WHERE username = ?", (username,)).fetchone()
  now = datetime.now(timezone.utc).isoformat()
  if row:
      con.execute("UPDATE FailedLogins SET fail_count = fail_count + 1, last_failed_at = ? WHERE username = ?", (now, username))
  else:
      con.execute("INSERT INTO FailedLogins(username, fail_count, last_failed_at) VALUES (?, ?, ?)", (username, 1, now))
  con.commit()

def reset_login_failures(username: str) -> None:
  """ This function removes the row pertaining to the given user from failed
  logins table.

  :param username: name of the user whose login failures are to be reset
  :type username: str
  ...
  :return: just updates the table and does not return anything
  :rtype: None
  """
  con.execute("DELETE FROM FailedLogins WHERE username = ?", (username,))
  con.commit()

"""# Test for the Login Lockout Functions"""

# testing the login lockout time calculation function
print(login_backoff_seconds(test_User.username))

# the lockout recording function updates the table itself and does not return anything
# TO DO: use record function and print the relevant row to see if it works

# testing the login failure reset function
# it similarly updates the table itself and does not return anything
# TO DO: use it and print the relevant row to see if it works

"""# Session Signature Function"""

# generates a token that will be used to create the unique session signature
server_secret = secrets.token_bytes(32)
def sign(text: str) -> str:
  """Generates the encoded signature of the text by hashing a secret key with
  the text input and returning it in a hexadecimal format

  :param text: takes the text which is to be encoded
  :type text: str
  ...
  :return: returns the signature
  :rtype: str
  """
  return hmac.digest(server_secret, text.encode(), 'sha256').hex()

"""# Test for the Signature Function"""

print(sign("randomtext"))


# DUPLICATED FROM HERE UNTIL RESET_LOGIN_FAILURES. CHECK


"""# User Authentication Functions"""


# -------------------- USER FUNCTIONS --------------------
def create_new_user(name: str, pw: str) -> User:
    """
    Create a new user with a hashed password and store them in the database.

    :param name: Username of the new user
    :type name: str
    :param pw: Plaintext password
    :type pw: str
    :return: A User object for the created user
    :rtype: User
    """
    salt_hex, hash_hex = hash_password(pw)
    con.execute(
        "INSERT INTO Users(username, password, token, password_salt, password_hash) VALUES (?, ?, ?, ?, ?)",
        (name, None, None, salt_hex, hash_hex)
    )
    con.commit()
    user_id = con.execute(
        "SELECT user_id FROM Users WHERE username = ?", (name,)
    ).fetchone()[0]
    return User(user_id=user_id, username=name, password="***", token=None)

def login(username: str, password: str, *, user_agent: Optional[str] = None, ip: Optional[str] = None) -> Optional[str]:
    """
    Authenticate a user and create a session.

    :param username: Username of the user
    :type username: str
    :param password: Plaintext password
    :type password: str
    :param user_agent: Client user agent, defaults to None
    :type user_agent: Optional[str], optional
    :param ip: Client IP address, defaults to None
    :type ip: Optional[str], optional
    :raises RuntimeError: If login lockout is active
    :return: Session token if login is successful, None otherwise
    :rtype: Optional[str]
    """
    wait = login_backoff_seconds(username)
    if wait > 0:
        raise RuntimeError(f"Too many attempts. Try again in {wait} seconds.")

    row = con.execute(
        "SELECT user_id, password_salt, password_hash FROM Users WHERE username = ?",
        (username,)
    ).fetchone()
    if not row:
        record_login_failure(username)
        return None

    user_id, salt_hex, hash_hex = row
    if not verify_password(password, salt_hex, hash_hex):
        record_login_failure(username)
        return None

    reset_login_failures(username)

    sessionid = secrets.token_urlsafe(16)
    signature = sign(sessionid)
    now_dt = datetime.now(timezone.utc)
    exp_dt = now_dt + timedelta(days=7)

    con.execute("""
        INSERT INTO Sessions(session_token, signature, user_id, created_at, expires_at, user_agent, ip)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    """, (
        sessionid,
        signature,
        user_id,
        now_dt.isoformat(),
        exp_dt.isoformat(),
        user_agent,
        ip
    ))
    con.commit()
    return f"{sessionid}_{signature}"

def logout(session_token: str) -> bool:
    """
    Log out a user by deleting their session.

    :param session_token: Session token string
    :type session_token: str
    :return: True if a session was deleted, False otherwise
    :rtype: bool
    """
    sessionid = session_token.split("_", 1)[0]
    cur = con.execute("DELETE FROM Sessions WHERE session_token = ?", (sessionid,))
    con.commit()
    return cur.rowcount > 0

def db_get_session_user(sessionid: str) -> int:
    """
    Retrieve the user ID for a given session.

    :param sessionid: Session token string
    :type sessionid: str
    :raises RuntimeError: If the session is expired or invalid
    :return: User ID
    :rtype: int
    """
    now = datetime.now(timezone.utc).isoformat()
    row = con.execute(
        "SELECT user_id FROM Sessions WHERE session_token = ? AND expires_at > ?",
        (sessionid, now)
    ).fetchone()
    if not row:
        raise RuntimeError("Session expired or invalid")
    return row[0]

"""# Tests for the User Authentication Functions"""

# Use a unique username for testing
test_user = create_new_user("testuser7", "pw1")
print(test_user)
print(login("testuser3", "pw1", user_agent=None, ip=None))

# Note: I think the unique constraint is throwing a lot of errors with the
# way the login function if written since it seems to be creating a new user
# every time it is called.
# To fix it, we can remove the unique constraint, since we have user ids
# to differentiate between different user, even it they have the same username.
# We can also rewrite the login function to fix the re-creation of the user,
# since that is not its intended use anyways