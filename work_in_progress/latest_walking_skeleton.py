# -*- coding: utf-8 -*-
"""28_08_25_Walking_Skeleton_PIM_Apurva_Anshika

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GIzKoWqPjbZbxeuFXPFTFlEWWMdwGvkX
"""

import sqlite3
from datetime import datetime

con = sqlite3.connect("pim.db")
cur = con.cursor()
cur.execute("CREATE TABLE IF NOT EXISTS Users(user_id INTEGER PRIMARY KEY AUTOINCREMENT, username, password, token)")
cur.execute("CREATE TABLE IF NOT EXISTS Particles(particle_id INTEGER PRIMARY KEY AUTOINCREMENT, date_created, date_updated, title, body, tags, particle_references)")

from dataclasses import dataclass, asdict
#creating User Class
@dataclass
class User:
  user_id: int | None # will be added via sql
  username: str
  password: str
  token: str | None

@dataclass
class Particle:
  particle_id: int | None # will be added via sql
  date_created: datetime
  date_updated: datetime
  title: str
  body: str
  tags: list
  particle_references: list

#test block 1
alvin = User(None, "Alvin", "alvinsandthechipmunks", None)
print(alvin)
alvin_particle = Particle(None, datetime.now(), datetime.now(), "Can Chipmunks sing?", "There's 3 movies on it, you tell me. #SingingChipmunks #ChipettesRule", [], [])
print(alvin_particle)

"""# Authentication Module

"""

import uuid

_users = {
    "anshika": "password123",
    "pari": "pari123",
}
_sessions = {}


def login(username: str, password: str) -> str | None:
    """
    Verifies credentials and returns a session token if valid.
    Returns None if login fails.
    """
    if username in _users and _users[username] == password:
        token = str(uuid.uuid4())
        _sessions[token] = username
        return token
    return None


def logout(session_token: str) -> bool:
    """
    Invalidates the session token. Returns True if successful.
    """
    if session_token in _sessions:
        del _sessions[session_token]
        return True
    return False

def create_new_user(name: str, pw: str) -> User:
    user = User(None, name, pw, None)
    return user

#test block 2
login("anshika", "password123")
# update the login function to store token in relevant User data
create_new_user("Theo", "icannotsingsad")

"""# Storage Module"""

import sqlite3

def convert_to_csstring(lst: list) -> str:
  return ",".join(lst) if lst else ""

def cstring_to_list(cstring: str) -> list:
  return cstring.split(",") if cstring else []

def store_user(user: User) -> None:
  """
  This function takes a user's data and stores it into the relevant SQL database
  """
  user_dict = asdict(user)
  # Remove user_id as it is AUTOINCREMENT
  del user_dict["user_id"]
  return cur.execute('INSERT INTO Users (username, password, token) VALUES (:username, :password, :token)', user_dict) and con.commit()

def store_particle(particle: Particle) -> None:
  """
  This function takes a particle and stores it into the relevant SQL database
  """
  particle_dict = asdict(particle)
  del particle_dict["particle_id"]
  particle_dict["tags"] = convert_to_csstring(particle_dict["tags"])
  particle_dict["particle_references"] = convert_to_csstring(particle_dict["particle_references"])
  return cur.execute('INSERT INTO Particles (date_created, date_updated, title, body, tags, particle_references) VALUES (:date_created, :date_updated, :title, :body, :tags, :particle_references)', particle_dict) and con.commit()

#test block 3
store_user(alvin)
store_particle(alvin_particle)

"""# Particle Module"""

from typing import Iterable, Optional
import os

def edit_Particle(particle: Particle, new_content: Iterable[str] | str, *,
                  save_to_disk: bool = True,
                  filepath: Optional[str] = None) -> Particle:
    """
    Update a particle's body without interactive input().
    - new_content: either a single string (full body) or an iterable of lines.
    - save_to_disk: if True, writes to disk (default True).
    - filepath: optional override for where to save (defaults to particle.title).
    Returns the updated Particle.
    """
    if isinstance(new_content, str):
        body_text = new_content
    else:
        body_text = "\n".join(list(new_content))

    # Update in-memory particle
    particle.body = body_text
    particle.date_updated = datetime.now()

    # Optionally persist to disk
    if save_to_disk:
        target = filepath or particle.title
        # Ensure parent dir exists if a path is given
        parent = os.path.dirname(target)
        if parent:
            os.makedirs(parent, exist_ok=True)
        with open(target, "w", encoding="utf-8") as f:
            f.write(body_text if body_text.endswith("\n") else body_text + "\n")

    print(f"File saved as {filepath or particle.title}" if save_to_disk else "Particle updated (in-memory only)")
    return particle

def create_Particle(title: str, body: str) -> Particle:
  """
  This function allows the user to create new particles to write in. It
  autogenerates an id, date_created, date_updated, tags and particle_references.
  """
  return Particle(None, datetime.now(), datetime.now(), title,
                  body, [], [])

def listParticles(query: str = "", page: int = 1, pageSize: int = 10):
  """
  This function lists relevant particles
  """
  results = [
      {
          "id": p["id"],
          "date": p["date"],
          "title": p["title"],
          "body": p["body"],
          "tags": p["tags"],
          }
        for p in Particles
        if query.lower() in p["title"].lower() or query.lower() in p["body"].lower()
    ] if query else [
        {
            "id": p["id"],
            "date": p["date"],
            "title": p["title"],
            "body": p["body"],
            "tags": p["tags"],
        }
        for p in Particles
        ]
  start = (page - 1) * pageSize
  end = start + pageSize
  return {"items": results[start:end], "total": len(results)}

def getParticle(id: int):
  """
  This function gets a specific particle
  """
  for p in Particles:
      if p["id"] == id:
          return p
  return None


def view_particles(query: str = "", page: int = 1, pageSize: int = 10) -> str:
  """
  This function allows the user to enter view mode for a specific particle
  """
  data = listParticles(query, page, pageSize)
  lis = []
  for it in data["items"]: #
      tags = " ".join(f"#{t}" for t in it["tags"])
      lis.append(
          f'<li><a href="/particles/{it["id"]}">{it["title"]}</a> '
          f'<small>{it["date"]}</small><br>'
          f'<span>{it["excerpt"]}</span><br>'
          f'<small>{tags}</small></li>'
      )
  return (
      f"<h2>Particles</h2>"
      f"<p>Total: {data['total']}</p>"
      f"<ul>{''.join(lis) or '<li>No results</li>'}</ul>"
  )

import re

def extract_tags_and_particle_refs(particle: Particle) -> Particle:
  """
  This function parses over a particle to extract tags and particle references
  and appends them to the respective lists of the particle and returns the
  updated particle.
  """
  tag_pattern = "#[a-zA-Z]+"
  particle_ref_pattern = "#[0-9]+"

  tags = re.findall(tag_pattern, particle.body)
  particle_refs = re.findall(particle_ref_pattern, particle.body)

  particle.tags = tags
  particle.particle_references = particle_refs

  return particle

p = Particle(1, datetime.now(), datetime.now(), "title", "#alpha #beta #gamma #epsilon #delta #lambda #1234 #4456 This is the body", [], [])
print(extract_tags_and_particle_refs(p))

con.commit()
con.close()